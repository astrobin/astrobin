# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Search::Xapian;
use base qw(Exporter);
use base qw(DynaLoader);
package Search::Xapianc;
bootstrap Search::Xapian;
package Search::Xapian;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Search::Xapian;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Search::Xapian;

*newN = *Search::Xapianc::newN;
*new3_WritableDatabase = *Search::Xapianc::new3_WritableDatabase;
*version_string = *Search::Xapianc::version_string;
*major_version = *Search::Xapianc::major_version;
*minor_version = *Search::Xapianc::minor_version;
*revision = *Search::Xapianc::revision;
*__eq__ = *Search::Xapianc::__eq__;
*__ne__ = *Search::Xapianc::__ne__;
*open_stub = *Search::Xapianc::open_stub;
*brass_open = *Search::Xapianc::brass_open;
*chert_open = *Search::Xapianc::chert_open;
*flint_open = *Search::Xapianc::flint_open;
*inmemory_open = *Search::Xapianc::inmemory_open;
*remote_open = *Search::Xapianc::remote_open;
*remote_open_writable = *Search::Xapianc::remote_open_writable;
*sortable_serialise = *Search::Xapianc::sortable_serialise;
*sortable_unserialise = *Search::Xapianc::sortable_unserialise;

############# Class : Search::Xapian::Error ##############

package Search::Xapian::Error;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*get_type = *Search::Xapianc::Error_get_type;
*get_msg = *Search::Xapianc::Error_get_msg;
*get_context = *Search::Xapianc::Error_get_context;
*get_error_string = *Search::Xapianc::Error_get_error_string;
*get_description = *Search::Xapianc::Error_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Error($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::LogicError ##############

package Search::Xapian::LogicError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Error Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_LogicError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::RuntimeError ##############

package Search::Xapian::RuntimeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Error Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_RuntimeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::AssertionError ##############

package Search::Xapian::AssertionError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::LogicError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_AssertionError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_AssertionError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::InvalidArgumentError ##############

package Search::Xapian::InvalidArgumentError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::LogicError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_InvalidArgumentError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_InvalidArgumentError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::InvalidOperationError ##############

package Search::Xapian::InvalidOperationError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::LogicError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_InvalidOperationError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_InvalidOperationError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::UnimplementedError ##############

package Search::Xapian::UnimplementedError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::LogicError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_UnimplementedError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_UnimplementedError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseError ##############

package Search::Xapian::DatabaseError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseCorruptError ##############

package Search::Xapian::DatabaseCorruptError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseCorruptError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseCorruptError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseCreateError ##############

package Search::Xapian::DatabaseCreateError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseCreateError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseCreateError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseLockError ##############

package Search::Xapian::DatabaseLockError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseLockError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseLockError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseModifiedError ##############

package Search::Xapian::DatabaseModifiedError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseModifiedError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseModifiedError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseOpeningError ##############

package Search::Xapian::DatabaseOpeningError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseOpeningError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseOpeningError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DatabaseVersionError ##############

package Search::Xapian::DatabaseVersionError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::DatabaseOpeningError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DatabaseVersionError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DatabaseVersionError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DocNotFoundError ##############

package Search::Xapian::DocNotFoundError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DocNotFoundError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DocNotFoundError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::FeatureUnavailableError ##############

package Search::Xapian::FeatureUnavailableError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_FeatureUnavailableError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_FeatureUnavailableError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::InternalError ##############

package Search::Xapian::InternalError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_InternalError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_InternalError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::NetworkError ##############

package Search::Xapian::NetworkError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_NetworkError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_NetworkError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::NetworkTimeoutError ##############

package Search::Xapian::NetworkTimeoutError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::NetworkError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_NetworkTimeoutError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_NetworkTimeoutError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::QueryParserError ##############

package Search::Xapian::QueryParserError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_QueryParserError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_QueryParserError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::SerialisationError ##############

package Search::Xapian::SerialisationError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_SerialisationError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_SerialisationError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::RangeError ##############

package Search::Xapian::RangeError;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::RuntimeError Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_RangeError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_RangeError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::PositionIterator ##############

package Search::Xapian::PositionIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_PositionIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_PositionIterator($self);
        delete $OWNER{$self};
    }
}

*get_termpos = *Search::Xapianc::PositionIterator_get_termpos;
*increment = *Search::Xapianc::PositionIterator_increment;
*equals = *Search::Xapianc::PositionIterator_equals;
*skip_to = *Search::Xapianc::PositionIterator_skip_to;
*get_description = *Search::Xapianc::PositionIterator_get_description;
*equal1 = *Search::Xapianc::PositionIterator_equal1;
*nequal1 = *Search::Xapianc::PositionIterator_nequal1;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::PostingIterator ##############

package Search::Xapian::PostingIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_PostingIterator($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_PostingIterator(@_);
    bless $self, $pkg if defined($self);
}

*skip_to = *Search::Xapianc::PostingIterator_skip_to;
*get_doclength = *Search::Xapianc::PostingIterator_get_doclength;
*get_wdf = *Search::Xapianc::PostingIterator_get_wdf;
*positionlist_begin = *Search::Xapianc::PostingIterator_positionlist_begin;
*positionlist_end = *Search::Xapianc::PostingIterator_positionlist_end;
*get_description = *Search::Xapianc::PostingIterator_get_description;
*get_docid = *Search::Xapianc::PostingIterator_get_docid;
*increment = *Search::Xapianc::PostingIterator_increment;
*equals = *Search::Xapianc::PostingIterator_equals;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::TermIterator ##############

package Search::Xapian::TermIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_TermIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_TermIterator($self);
        delete $OWNER{$self};
    }
}

*get_termname = *Search::Xapianc::TermIterator_get_termname;
*increment = *Search::Xapianc::TermIterator_increment;
*equals = *Search::Xapianc::TermIterator_equals;
*skip_to = *Search::Xapianc::TermIterator_skip_to;
*get_wdf = *Search::Xapianc::TermIterator_get_wdf;
*get_termfreq = *Search::Xapianc::TermIterator_get_termfreq;
*positionlist_begin = *Search::Xapianc::TermIterator_positionlist_begin;
*positionlist_end = *Search::Xapianc::TermIterator_positionlist_end;
*get_description = *Search::Xapianc::TermIterator_get_description;
*equal = *Search::Xapianc::TermIterator_equal;
*nequal = *Search::Xapianc::TermIterator_nequal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueIterator ##############

package Search::Xapian::ValueIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValueIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueIterator($self);
        delete $OWNER{$self};
    }
}

*get_value = *Search::Xapianc::ValueIterator_get_value;
*increment = *Search::Xapianc::ValueIterator_increment;
*equals = *Search::Xapianc::ValueIterator_equals;
*get_docid = *Search::Xapianc::ValueIterator_get_docid;
*get_valueno = *Search::Xapianc::ValueIterator_get_valueno;
*skip_to = *Search::Xapianc::ValueIterator_skip_to;
*check = *Search::Xapianc::ValueIterator_check;
*get_description = *Search::Xapianc::ValueIterator_get_description;
*equal = *Search::Xapianc::ValueIterator_equal;
*nequal = *Search::Xapianc::ValueIterator_nequal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Document ##############

package Search::Xapian::Document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Document(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Document($self);
        delete $OWNER{$self};
    }
}

*get_value = *Search::Xapianc::Document_get_value;
*add_value = *Search::Xapianc::Document_add_value;
*remove_value = *Search::Xapianc::Document_remove_value;
*clear_values = *Search::Xapianc::Document_clear_values;
*get_data = *Search::Xapianc::Document_get_data;
*set_data = *Search::Xapianc::Document_set_data;
*add_posting = *Search::Xapianc::Document_add_posting;
*add_term = *Search::Xapianc::Document_add_term;
*add_boolean_term = *Search::Xapianc::Document_add_boolean_term;
*remove_posting = *Search::Xapianc::Document_remove_posting;
*remove_term = *Search::Xapianc::Document_remove_term;
*clear_terms = *Search::Xapianc::Document_clear_terms;
*termlist_count = *Search::Xapianc::Document_termlist_count;
*termlist_begin = *Search::Xapianc::Document_termlist_begin;
*termlist_end = *Search::Xapianc::Document_termlist_end;
*values_count = *Search::Xapianc::Document_values_count;
*values_begin = *Search::Xapianc::Document_values_begin;
*values_end = *Search::Xapianc::Document_values_end;
*get_docid = *Search::Xapianc::Document_get_docid;
*serialise = *Search::Xapianc::Document_serialise;
*unserialise = *Search::Xapianc::Document_unserialise;
*get_description = *Search::Xapianc::Document_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::PostingSource ##############

package Search::Xapian::PostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_PostingSource($self);
        delete $OWNER{$self};
    }
}

*get_termfreq_min = *Search::Xapianc::PostingSource_get_termfreq_min;
*get_termfreq_est = *Search::Xapianc::PostingSource_get_termfreq_est;
*get_termfreq_max = *Search::Xapianc::PostingSource_get_termfreq_max;
*get_maxweight = *Search::Xapianc::PostingSource_get_maxweight;
*get_weight = *Search::Xapianc::PostingSource_get_weight;
*get_docid = *Search::Xapianc::PostingSource_get_docid;
*increment_weight = *Search::Xapianc::PostingSource_increment_weight;
*skip_to = *Search::Xapianc::PostingSource_skip_to;
*check = *Search::Xapianc::PostingSource_check;
*at_end = *Search::Xapianc::PostingSource_at_end;
*name = *Search::Xapianc::PostingSource_name;
*init = *Search::Xapianc::PostingSource_init;
*get_description = *Search::Xapianc::PostingSource_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValuePostingSource ##############

package Search::Xapian::ValuePostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::PostingSource Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValuePostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *Search::Xapianc::ValuePostingSource_get_termfreq_min;
*get_termfreq_est = *Search::Xapianc::ValuePostingSource_get_termfreq_est;
*get_termfreq_max = *Search::Xapianc::ValuePostingSource_get_termfreq_max;
*increment_weight = *Search::Xapianc::ValuePostingSource_increment_weight;
*skip_to = *Search::Xapianc::ValuePostingSource_skip_to;
*check = *Search::Xapianc::ValuePostingSource_check;
*at_end = *Search::Xapianc::ValuePostingSource_at_end;
*get_docid = *Search::Xapianc::ValuePostingSource_get_docid;
*init = *Search::Xapianc::ValuePostingSource_init;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValuePostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueWeightPostingSource ##############

package Search::Xapian::ValueWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::ValuePostingSource Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValueWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *Search::Xapianc::ValueWeightPostingSource_get_weight;
*name = *Search::Xapianc::ValueWeightPostingSource_name;
*init = *Search::Xapianc::ValueWeightPostingSource_init;
*get_description = *Search::Xapianc::ValueWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DecreasingValueWeightPostingSource ##############

package Search::Xapian::DecreasingValueWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::ValueWeightPostingSource Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DecreasingValueWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_weight = *Search::Xapianc::DecreasingValueWeightPostingSource_get_weight;
*name = *Search::Xapianc::DecreasingValueWeightPostingSource_name;
*init = *Search::Xapianc::DecreasingValueWeightPostingSource_init;
*increment_weight = *Search::Xapianc::DecreasingValueWeightPostingSource_increment_weight;
*skip_to = *Search::Xapianc::DecreasingValueWeightPostingSource_skip_to;
*check = *Search::Xapianc::DecreasingValueWeightPostingSource_check;
*get_description = *Search::Xapianc::DecreasingValueWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DecreasingValueWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueMapPostingSource ##############

package Search::Xapian::ValueMapPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::ValuePostingSource Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValueMapPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*add_mapping = *Search::Xapianc::ValueMapPostingSource_add_mapping;
*clear_mappings = *Search::Xapianc::ValueMapPostingSource_clear_mappings;
*set_default_weight = *Search::Xapianc::ValueMapPostingSource_set_default_weight;
*get_weight = *Search::Xapianc::ValueMapPostingSource_get_weight;
*name = *Search::Xapianc::ValueMapPostingSource_name;
*init = *Search::Xapianc::ValueMapPostingSource_init;
*get_description = *Search::Xapianc::ValueMapPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueMapPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::FixedWeightPostingSource ##############

package Search::Xapian::FixedWeightPostingSource;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::PostingSource Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_FixedWeightPostingSource(@_);
    bless $self, $pkg if defined($self);
}

*get_termfreq_min = *Search::Xapianc::FixedWeightPostingSource_get_termfreq_min;
*get_termfreq_est = *Search::Xapianc::FixedWeightPostingSource_get_termfreq_est;
*get_termfreq_max = *Search::Xapianc::FixedWeightPostingSource_get_termfreq_max;
*get_weight = *Search::Xapianc::FixedWeightPostingSource_get_weight;
*increment_weight = *Search::Xapianc::FixedWeightPostingSource_increment_weight;
*skip_to = *Search::Xapianc::FixedWeightPostingSource_skip_to;
*check = *Search::Xapianc::FixedWeightPostingSource_check;
*at_end = *Search::Xapianc::FixedWeightPostingSource_at_end;
*get_docid = *Search::Xapianc::FixedWeightPostingSource_get_docid;
*name = *Search::Xapianc::FixedWeightPostingSource_name;
*init = *Search::Xapianc::FixedWeightPostingSource_init;
*get_description = *Search::Xapianc::FixedWeightPostingSource_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_FixedWeightPostingSource($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MSet ##############

package Search::Xapian::MSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_MSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MSet($self);
        delete $OWNER{$self};
    }
}

*fetch = *Search::Xapianc::MSet_fetch;
*convert_to_percent = *Search::Xapianc::MSet_convert_to_percent;
*get_termfreq = *Search::Xapianc::MSet_get_termfreq;
*get_termweight = *Search::Xapianc::MSet_get_termweight;
*get_firstitem = *Search::Xapianc::MSet_get_firstitem;
*get_matches_lower_bound = *Search::Xapianc::MSet_get_matches_lower_bound;
*get_matches_estimated = *Search::Xapianc::MSet_get_matches_estimated;
*get_matches_upper_bound = *Search::Xapianc::MSet_get_matches_upper_bound;
*get_uncollapsed_matches_lower_bound = *Search::Xapianc::MSet_get_uncollapsed_matches_lower_bound;
*get_uncollapsed_matches_estimated = *Search::Xapianc::MSet_get_uncollapsed_matches_estimated;
*get_uncollapsed_matches_upper_bound = *Search::Xapianc::MSet_get_uncollapsed_matches_upper_bound;
*get_max_possible = *Search::Xapianc::MSet_get_max_possible;
*get_max_attained = *Search::Xapianc::MSet_get_max_attained;
*size = *Search::Xapianc::MSet_size;
*empty = *Search::Xapianc::MSet_empty;
*begin = *Search::Xapianc::MSet_begin;
*end = *Search::Xapianc::MSet_end;
*back = *Search::Xapianc::MSet_back;
*get_hit = *Search::Xapianc::MSet_get_hit;
*get_document_percentage = *Search::Xapianc::MSet_get_document_percentage;
*get_document = *Search::Xapianc::MSet_get_document;
*get_docid = *Search::Xapianc::MSet_get_docid;
*get_description = *Search::Xapianc::MSet_get_description;
*FETCH = *Search::Xapianc::MSet_FETCH;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MSetIterator ##############

package Search::Xapian::MSetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_MSetIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MSetIterator($self);
        delete $OWNER{$self};
    }
}

*get_docid = *Search::Xapianc::MSetIterator_get_docid;
*increment = *Search::Xapianc::MSetIterator_increment;
*prev = *Search::Xapianc::MSetIterator_prev;
*equals = *Search::Xapianc::MSetIterator_equals;
*get_document = *Search::Xapianc::MSetIterator_get_document;
*get_rank = *Search::Xapianc::MSetIterator_get_rank;
*get_weight = *Search::Xapianc::MSetIterator_get_weight;
*get_collapse_key = *Search::Xapianc::MSetIterator_get_collapse_key;
*get_collapse_count = *Search::Xapianc::MSetIterator_get_collapse_count;
*get_percent = *Search::Xapianc::MSetIterator_get_percent;
*get_description = *Search::Xapianc::MSetIterator_get_description;
*equal = *Search::Xapianc::MSetIterator_equal;
*nequal = *Search::Xapianc::MSetIterator_nequal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ESet ##############

package Search::Xapian::ESet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ESet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ESet($self);
        delete $OWNER{$self};
    }
}

*get_ebound = *Search::Xapianc::ESet_get_ebound;
*size = *Search::Xapianc::ESet_size;
*empty = *Search::Xapianc::ESet_empty;
*begin = *Search::Xapianc::ESet_begin;
*end = *Search::Xapianc::ESet_end;
*back = *Search::Xapianc::ESet_back;
*get_description = *Search::Xapianc::ESet_get_description;
*FETCH = *Search::Xapianc::ESet_FETCH;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ESetIterator ##############

package Search::Xapian::ESetIterator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ESetIterator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ESetIterator($self);
        delete $OWNER{$self};
    }
}

*get_term = *Search::Xapianc::ESetIterator_get_term;
*increment = *Search::Xapianc::ESetIterator_increment;
*prev = *Search::Xapianc::ESetIterator_prev;
*equals = *Search::Xapianc::ESetIterator_equals;
*get_weight = *Search::Xapianc::ESetIterator_get_weight;
*get_description = *Search::Xapianc::ESetIterator_get_description;
*get_termname = *Search::Xapianc::ESetIterator_get_termname;
*equal = *Search::Xapianc::ESetIterator_equal;
*nequal = *Search::Xapianc::ESetIterator_nequal;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::RSet ##############

package Search::Xapian::RSet;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_RSet(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_RSet($self);
        delete $OWNER{$self};
    }
}

*size = *Search::Xapianc::RSet_size;
*empty = *Search::Xapianc::RSet_empty;
*add_document = *Search::Xapianc::RSet_add_document;
*remove_document = *Search::Xapianc::RSet_remove_document;
*contains = *Search::Xapianc::RSet_contains;
*get_description = *Search::Xapianc::RSet_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MatchDecider ##############

package Search::Xapian::MatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Search::Xapianc::MatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Enquire ##############

package Search::Xapian::Enquire;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Enquire(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Enquire($self);
        delete $OWNER{$self};
    }
}

sub set_query {
  my $self = shift;
  my $query = shift;
  if( ref( $query ) ne 'Search::Xapian::Query' ) {
    $query = Search::Xapian::Query->new( $query, @_ );
    Search::Xapianc::Enquire_set_query( $self, $query );
    return;
  }
  my $nargs = scalar(@_);
  if( $nargs > 1) {
    Carp::carp( "USAGE: \$enquire->set_query(\$query) or \$enquire->set_query(\$query, \$length)" );
    exit;
  }
  Search::Xapianc::Enquire_set_query( $self, $query, @_ );
}

*get_query = *Search::Xapianc::Enquire_get_query;
*add_matchspy = *Search::Xapianc::Enquire_add_matchspy;
*clear_matchspies = *Search::Xapianc::Enquire_clear_matchspies;
*set_weighting_scheme = *Search::Xapianc::Enquire_set_weighting_scheme;
*set_collapse_key = *Search::Xapianc::Enquire_set_collapse_key;
*ASCENDING = *Search::Xapianc::Enquire_ASCENDING;
*DESCENDING = *Search::Xapianc::Enquire_DESCENDING;
*DONT_CARE = *Search::Xapianc::Enquire_DONT_CARE;
*set_docid_order = *Search::Xapianc::Enquire_set_docid_order;
*set_cutoff = *Search::Xapianc::Enquire_set_cutoff;
*set_sort_by_relevance = *Search::Xapianc::Enquire_set_sort_by_relevance;
*set_sort_by_value = *Search::Xapianc::Enquire_set_sort_by_value;
*set_sort_by_value_then_relevance = *Search::Xapianc::Enquire_set_sort_by_value_then_relevance;
*set_sort_by_relevance_then_value = *Search::Xapianc::Enquire_set_sort_by_relevance_then_value;
sub set_sort_by_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Search::Xapianc::Enquire_set_sort_by_key( @_ );
}

sub set_sort_by_key_then_relevance {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Search::Xapianc::Enquire_set_sort_by_key_then_relevance( @_ );
}

sub set_sort_by_relevance_then_key {
    my $self = $_[0];
    my $sorter = $_[1];
    $self{_sorter} = $sorter;
    Search::Xapianc::Enquire_set_sort_by_relevance_then_key( @_ );
}

*INCLUDE_QUERY_TERMS = *Search::Xapianc::Enquire_INCLUDE_QUERY_TERMS;
*INCLUDE_QUERY_TERMS = *Search::Xapianc::Enquire_INCLUDE_QUERY_TERMS;
*USE_EXACT_TERMFREQ = *Search::Xapianc::Enquire_USE_EXACT_TERMFREQ;
*USE_EXACT_TERMFREQ = *Search::Xapianc::Enquire_USE_EXACT_TERMFREQ;
sub get_mset {
  my $self = $_[0];
  my $nargs = scalar(@_);
  if( $nargs == 4 ) {
    my $type = ref( $_[2] );
    if ( $type eq 'Search::Xapian::RSet' ) {
      # get_mset(first, max, rset)
      splice @_, 2, 0, (0); # insert checkatleast
    }
  }
  return Search::Xapianc::Enquire_get_mset( @_ );
}

*get_eset = *Search::Xapianc::Enquire_get_eset;
*get_matching_terms_begin = *Search::Xapianc::Enquire_get_matching_terms_begin;
*get_matching_terms_end = *Search::Xapianc::Enquire_get_matching_terms_end;
*get_description = *Search::Xapianc::Enquire_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Registry ##############

package Search::Xapian::Registry;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Registry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Registry($self);
        delete $OWNER{$self};
    }
}

*register_weighting_scheme = *Search::Xapianc::Registry_register_weighting_scheme;
*get_weighting_scheme = *Search::Xapianc::Registry_get_weighting_scheme;
*register_posting_source = *Search::Xapianc::Registry_register_posting_source;
*get_posting_source = *Search::Xapianc::Registry_get_posting_source;
*register_match_spy = *Search::Xapianc::Registry_register_match_spy;
*get_match_spy = *Search::Xapianc::Registry_get_match_spy;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Weight ##############

package Search::Xapian::Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Weight($self);
        delete $OWNER{$self};
    }
}

*name = *Search::Xapianc::Weight_name;
*get_sumpart = *Search::Xapianc::Weight_get_sumpart;
*get_maxpart = *Search::Xapianc::Weight_get_maxpart;
*get_sumextra = *Search::Xapianc::Weight_get_sumextra;
*get_maxextra = *Search::Xapianc::Weight_get_maxextra;
*get_sumpart_needs_doclength_ = *Search::Xapianc::Weight_get_sumpart_needs_doclength_;
*get_sumpart_needs_wdf_ = *Search::Xapianc::Weight_get_sumpart_needs_wdf_;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::BoolWeight ##############

package Search::Xapian::BoolWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Weight Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_BoolWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Search::Xapianc::BoolWeight_name;
*get_sumpart = *Search::Xapianc::BoolWeight_get_sumpart;
*get_maxpart = *Search::Xapianc::BoolWeight_get_maxpart;
*get_sumextra = *Search::Xapianc::BoolWeight_get_sumextra;
*get_maxextra = *Search::Xapianc::BoolWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_BoolWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::BM25Weight ##############

package Search::Xapian::BM25Weight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Weight Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_BM25Weight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Search::Xapianc::BM25Weight_name;
*get_sumpart = *Search::Xapianc::BM25Weight_get_sumpart;
*get_maxpart = *Search::Xapianc::BM25Weight_get_maxpart;
*get_sumextra = *Search::Xapianc::BM25Weight_get_sumextra;
*get_maxextra = *Search::Xapianc::BM25Weight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_BM25Weight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::TradWeight ##############

package Search::Xapian::TradWeight;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Weight Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_TradWeight(@_);
    bless $self, $pkg if defined($self);
}

*name = *Search::Xapianc::TradWeight_name;
*get_sumpart = *Search::Xapianc::TradWeight_get_sumpart;
*get_maxpart = *Search::Xapianc::TradWeight_get_maxpart;
*get_sumextra = *Search::Xapianc::TradWeight_get_sumextra;
*get_maxextra = *Search::Xapianc::TradWeight_get_maxextra;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_TradWeight($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MatchSpy ##############

package Search::Xapian::MatchSpy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MatchSpy($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Search::Xapianc::MatchSpy___call__;
*name = *Search::Xapianc::MatchSpy_name;
*merge_results = *Search::Xapianc::MatchSpy_merge_results;
*get_description = *Search::Xapianc::MatchSpy_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueCountMatchSpy ##############

package Search::Xapian::ValueCountMatchSpy;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::MatchSpy Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValueCountMatchSpy(@_);
    bless $self, $pkg if defined($self);
}

*get_total = *Search::Xapianc::ValueCountMatchSpy_get_total;
*values_begin = *Search::Xapianc::ValueCountMatchSpy_values_begin;
*values_end = *Search::Xapianc::ValueCountMatchSpy_values_end;
*top_values_begin = *Search::Xapianc::ValueCountMatchSpy_top_values_begin;
*top_values_end = *Search::Xapianc::ValueCountMatchSpy_top_values_end;
*__call__ = *Search::Xapianc::ValueCountMatchSpy___call__;
*name = *Search::Xapianc::ValueCountMatchSpy_name;
*merge_results = *Search::Xapianc::ValueCountMatchSpy_merge_results;
*get_description = *Search::Xapianc::ValueCountMatchSpy_get_description;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueCountMatchSpy($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Database ##############

package Search::Xapian::Database;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*add_database = *Search::Xapianc::Database_add_database;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Database($self);
        delete $OWNER{$self};
    }
}

sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Database(@_);
    bless $self, $pkg if defined($self);
}

*reopen = *Search::Xapianc::Database_reopen;
*close = *Search::Xapianc::Database_close;
*get_description = *Search::Xapianc::Database_get_description;
*postlist_begin = *Search::Xapianc::Database_postlist_begin;
*postlist_end = *Search::Xapianc::Database_postlist_end;
*termlist_begin = *Search::Xapianc::Database_termlist_begin;
*termlist_end = *Search::Xapianc::Database_termlist_end;
*positionlist_begin = *Search::Xapianc::Database_positionlist_begin;
*positionlist_end = *Search::Xapianc::Database_positionlist_end;
*allterms_begin = *Search::Xapianc::Database_allterms_begin;
*allterms_end = *Search::Xapianc::Database_allterms_end;
*get_doccount = *Search::Xapianc::Database_get_doccount;
*get_lastdocid = *Search::Xapianc::Database_get_lastdocid;
*get_avlength = *Search::Xapianc::Database_get_avlength;
*get_termfreq = *Search::Xapianc::Database_get_termfreq;
*term_exists = *Search::Xapianc::Database_term_exists;
*get_collection_freq = *Search::Xapianc::Database_get_collection_freq;
*get_value_freq = *Search::Xapianc::Database_get_value_freq;
*get_value_lower_bound = *Search::Xapianc::Database_get_value_lower_bound;
*get_value_upper_bound = *Search::Xapianc::Database_get_value_upper_bound;
*get_doclength_lower_bound = *Search::Xapianc::Database_get_doclength_lower_bound;
*get_doclength_upper_bound = *Search::Xapianc::Database_get_doclength_upper_bound;
*get_wdf_upper_bound = *Search::Xapianc::Database_get_wdf_upper_bound;
*valuestream_begin = *Search::Xapianc::Database_valuestream_begin;
*valuestream_end = *Search::Xapianc::Database_valuestream_end;
*get_doclength = *Search::Xapianc::Database_get_doclength;
*keep_alive = *Search::Xapianc::Database_keep_alive;
*get_document = *Search::Xapianc::Database_get_document;
*get_spelling_suggestion = *Search::Xapianc::Database_get_spelling_suggestion;
*spellings_begin = *Search::Xapianc::Database_spellings_begin;
*spellings_end = *Search::Xapianc::Database_spellings_end;
*synonyms_begin = *Search::Xapianc::Database_synonyms_begin;
*synonyms_end = *Search::Xapianc::Database_synonyms_end;
*synonym_keys_begin = *Search::Xapianc::Database_synonym_keys_begin;
*synonym_keys_end = *Search::Xapianc::Database_synonym_keys_end;
*get_metadata = *Search::Xapianc::Database_get_metadata;
*metadata_keys_begin = *Search::Xapianc::Database_metadata_keys_begin;
*metadata_keys_end = *Search::Xapianc::Database_metadata_keys_end;
*get_uuid = *Search::Xapianc::Database_get_uuid;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::WritableDatabase ##############

package Search::Xapian::WritableDatabase;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Database Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_WritableDatabase($self);
        delete $OWNER{$self};
    }
}

sub new {
  my $pkg = shift;
  my $self;
  if( scalar(@_) == 0 ) {
    $self = Search::Xapianc::new3_WritableDatabase(@_);
  } else {
    $self = Search::Xapianc::new_WritableDatabase(@_);
  }
  bless $self, $pkg if defined($self);
}

*commit = *Search::Xapianc::WritableDatabase_commit;
*flush = *Search::Xapianc::WritableDatabase_flush;
*begin_transaction = *Search::Xapianc::WritableDatabase_begin_transaction;
*commit_transaction = *Search::Xapianc::WritableDatabase_commit_transaction;
*cancel_transaction = *Search::Xapianc::WritableDatabase_cancel_transaction;
*add_document = *Search::Xapianc::WritableDatabase_add_document;
*delete_document = *Search::Xapianc::WritableDatabase_delete_document;
*replace_document = *Search::Xapianc::WritableDatabase_replace_document;
*add_spelling = *Search::Xapianc::WritableDatabase_add_spelling;
*remove_spelling = *Search::Xapianc::WritableDatabase_remove_spelling;
*add_synonym = *Search::Xapianc::WritableDatabase_add_synonym;
*remove_synonym = *Search::Xapianc::WritableDatabase_remove_synonym;
*clear_synonyms = *Search::Xapianc::WritableDatabase_clear_synonyms;
*set_metadata = *Search::Xapianc::WritableDatabase_set_metadata;
*get_description = *Search::Xapianc::WritableDatabase_get_description;
*replace_document_by_term = *Search::Xapianc::WritableDatabase_replace_document_by_term;
*delete_document_by_term = *Search::Xapianc::WritableDatabase_delete_document_by_term;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Query ##############

package Search::Xapian::Query;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*OP_AND = *Search::Xapianc::Query_OP_AND;
*OP_OR = *Search::Xapianc::Query_OP_OR;
*OP_AND_NOT = *Search::Xapianc::Query_OP_AND_NOT;
*OP_XOR = *Search::Xapianc::Query_OP_XOR;
*OP_AND_MAYBE = *Search::Xapianc::Query_OP_AND_MAYBE;
*OP_FILTER = *Search::Xapianc::Query_OP_FILTER;
*OP_NEAR = *Search::Xapianc::Query_OP_NEAR;
*OP_PHRASE = *Search::Xapianc::Query_OP_PHRASE;
*OP_VALUE_RANGE = *Search::Xapianc::Query_OP_VALUE_RANGE;
*OP_SCALE_WEIGHT = *Search::Xapianc::Query_OP_SCALE_WEIGHT;
*OP_ELITE_SET = *Search::Xapianc::Query_OP_ELITE_SET;
*OP_VALUE_GE = *Search::Xapianc::Query_OP_VALUE_GE;
*OP_VALUE_LE = *Search::Xapianc::Query_OP_VALUE_LE;
*OP_SYNONYM = *Search::Xapianc::Query_OP_SYNONYM;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Query($self);
        delete $OWNER{$self};
    }
}

*get_length = *Search::Xapianc::Query_get_length;
*get_terms_begin = *Search::Xapianc::Query_get_terms_begin;
*get_terms_end = *Search::Xapianc::Query_get_terms_end;
*empty = *Search::Xapianc::Query_empty;
*serialise = *Search::Xapianc::Query_serialise;
*unserialise = *Search::Xapianc::Query_unserialise;
*get_description = *Search::Xapianc::Query_get_description;
sub new {
  my $class = shift;
  my $query;

  if( @_ == 1 ) {
    $query = Search::Xapianc::new_Query(@_);
  } else {
    my $op = $_[0];
    if( $op !~ /^\d+$/ ) {
	Carp::croak( "USAGE: $class->new('term') or $class->new(OP, <args>)" );
    }
    if( $op == 8 ) { # FIXME: 8 is OP_VALUE_RANGE; eliminate hardcoded literal
      if( @_ != 4 ) {
	Carp::croak( "USAGE: $class->new(OP_VALUE_RANGE, VALNO, START, END)" );
      }
      $query = Search::Xapianc::new_Query( @_ );
    } elsif( $op == 9 ) { # FIXME: OP_SCALE_WEIGHT
      if( @_ != 3 ) {
        Carp::croak( "USAGE: $class->new(OP_SCALE_WEIGHT, QUERY, FACTOR)" );
      }
      $query = Search::Xapianc::new_Query( @_ );
    } elsif( $op == 11 || $op == 12 ) { # FIXME: OP_VALUE_GE, OP_VALUE_LE; eliminate hardcoded literals
      if( @_ != 3 ) {
        Carp::croak( "USAGE: $class->new(OP_VALUE_[GL]E, VALNO, LIMIT)" );
      }
      $query = Search::Xapianc::new_Query( @_ );
    } else {
      shift @_;
      $query = Search::Xapian::newN( $op, \@_ );
    }
  }
  return $query;
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Stopper ##############

package Search::Xapian::Stopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Search::Xapianc::Stopper___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Stopper($self);
        delete $OWNER{$self};
    }
}

*get_description = *Search::Xapianc::Stopper_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::SimpleStopper ##############

package Search::Xapian::SimpleStopper;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Stopper Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $class = shift;
    my $stopper = Search::Xapianc::new_SimpleStopper();

    bless $stopper, $class;
    foreach (@_) {
	$stopper->add($_);
    }

    return $stopper;
}

*add = *Search::Xapianc::SimpleStopper_add;
*__call__ = *Search::Xapianc::SimpleStopper___call__;
*get_description = *Search::Xapianc::SimpleStopper_get_description;
*stop_word = *Search::Xapianc::SimpleStopper_stop_word;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_SimpleStopper($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueRangeProcessor ##############

package Search::Xapian::ValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Search::Xapianc::ValueRangeProcessor___call__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::StringValueRangeProcessor ##############

package Search::Xapian::StringValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::ValueRangeProcessor Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_StringValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Search::Xapianc::StringValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_StringValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::DateValueRangeProcessor ##############

package Search::Xapian::DateValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::StringValueRangeProcessor Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_DateValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Search::Xapianc::DateValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_DateValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::NumberValueRangeProcessor ##############

package Search::Xapian::NumberValueRangeProcessor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::StringValueRangeProcessor Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_NumberValueRangeProcessor(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Search::Xapianc::NumberValueRangeProcessor___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_NumberValueRangeProcessor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::QueryParser ##############

package Search::Xapian::QueryParser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*FLAG_BOOLEAN = *Search::Xapianc::QueryParser_FLAG_BOOLEAN;
*FLAG_PHRASE = *Search::Xapianc::QueryParser_FLAG_PHRASE;
*FLAG_LOVEHATE = *Search::Xapianc::QueryParser_FLAG_LOVEHATE;
*FLAG_BOOLEAN_ANY_CASE = *Search::Xapianc::QueryParser_FLAG_BOOLEAN_ANY_CASE;
*FLAG_WILDCARD = *Search::Xapianc::QueryParser_FLAG_WILDCARD;
*FLAG_PURE_NOT = *Search::Xapianc::QueryParser_FLAG_PURE_NOT;
*FLAG_PARTIAL = *Search::Xapianc::QueryParser_FLAG_PARTIAL;
*FLAG_SPELLING_CORRECTION = *Search::Xapianc::QueryParser_FLAG_SPELLING_CORRECTION;
*FLAG_SYNONYM = *Search::Xapianc::QueryParser_FLAG_SYNONYM;
*FLAG_AUTO_SYNONYMS = *Search::Xapianc::QueryParser_FLAG_AUTO_SYNONYMS;
*FLAG_AUTO_MULTIWORD_SYNONYMS = *Search::Xapianc::QueryParser_FLAG_AUTO_MULTIWORD_SYNONYMS;
*FLAG_DEFAULT = *Search::Xapianc::QueryParser_FLAG_DEFAULT;
*STEM_NONE = *Search::Xapianc::QueryParser_STEM_NONE;
*STEM_SOME = *Search::Xapianc::QueryParser_STEM_SOME;
*STEM_ALL = *Search::Xapianc::QueryParser_STEM_ALL;
sub new {
  my $class = shift;
  my $qp = Search::Xapianc::new_QueryParser();

  bless $qp, $class;
  $qp->set_database(@_) if scalar(@_) == 1;

  return $qp;
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_QueryParser($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *Search::Xapianc::QueryParser_set_stemmer;
*set_stemming_strategy = *Search::Xapianc::QueryParser_set_stemming_strategy;
sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    Search::Xapianc::QueryParser_set_stopper( @_ );
}

*set_default_op = *Search::Xapianc::QueryParser_set_default_op;
*get_default_op = *Search::Xapianc::QueryParser_get_default_op;
*set_database = *Search::Xapianc::QueryParser_set_database;
*set_max_wildcard_expansion = *Search::Xapianc::QueryParser_set_max_wildcard_expansion;
*parse_query = *Search::Xapianc::QueryParser_parse_query;
*add_prefix = *Search::Xapianc::QueryParser_add_prefix;
*add_boolean_prefix = *Search::Xapianc::QueryParser_add_boolean_prefix;
*stoplist_begin = *Search::Xapianc::QueryParser_stoplist_begin;
*stoplist_end = *Search::Xapianc::QueryParser_stoplist_end;
*unstem_begin = *Search::Xapianc::QueryParser_unstem_begin;
*unstem_end = *Search::Xapianc::QueryParser_unstem_end;
sub add_valuerangeprocessor {
    my ($self, $vrproc) = @_;
    push @{$self{_vrproc}}, $vrproc;
    Search::Xapianc::QueryParser_add_valuerangeprocessor( @_ );
}

*get_corrected_query_string = *Search::Xapianc::QueryParser_get_corrected_query_string;
*get_description = *Search::Xapianc::QueryParser_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Stem ##############

package Search::Xapian::Stem;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Stem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Stem($self);
        delete $OWNER{$self};
    }
}

*__call__ = *Search::Xapianc::Stem___call__;
*get_description = *Search::Xapianc::Stem_get_description;
*get_available_languages = *Search::Xapianc::Stem_get_available_languages;
*stem_word = *Search::Xapianc::Stem_stem_word;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::TermGenerator ##############

package Search::Xapian::TermGenerator;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_TermGenerator(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_TermGenerator($self);
        delete $OWNER{$self};
    }
}

*set_stemmer = *Search::Xapianc::TermGenerator_set_stemmer;
*set_stopper = *Search::Xapianc::TermGenerator_set_stopper;
*set_document = *Search::Xapianc::TermGenerator_set_document;
*get_document = *Search::Xapianc::TermGenerator_get_document;
*set_database = *Search::Xapianc::TermGenerator_set_database;
*FLAG_SPELLING = *Search::Xapianc::TermGenerator_FLAG_SPELLING;
*set_flags = *Search::Xapianc::TermGenerator_set_flags;
*index_text = *Search::Xapianc::TermGenerator_index_text;
*index_text_without_positions = *Search::Xapianc::TermGenerator_index_text_without_positions;
*increase_termpos = *Search::Xapianc::TermGenerator_increase_termpos;
*get_termpos = *Search::Xapianc::TermGenerator_get_termpos;
*set_termpos = *Search::Xapianc::TermGenerator_set_termpos;
*get_description = *Search::Xapianc::TermGenerator_get_description;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::KeyMaker ##############

package Search::Xapian::KeyMaker;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*__call__ = *Search::Xapianc::KeyMaker___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_KeyMaker($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MultiValueKeyMaker ##############

package Search::Xapian::MultiValueKeyMaker;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::KeyMaker Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_MultiValueKeyMaker(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Search::Xapianc::MultiValueKeyMaker___call__;
*add_value = *Search::Xapianc::MultiValueKeyMaker_add_value;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MultiValueKeyMaker($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Sorter ##############

package Search::Xapian::Sorter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::KeyMaker Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Sorter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::MultiValueSorter ##############

package Search::Xapian::MultiValueSorter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::Sorter Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_MultiValueSorter(@_);
    bless $self, $pkg if defined($self);
}

*__call__ = *Search::Xapianc::MultiValueSorter___call__;
*add = *Search::Xapianc::MultiValueSorter_add;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_MultiValueSorter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::ValueSetMatchDecider ##############

package Search::Xapian::ValueSetMatchDecider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian::MatchDecider Search::Xapian );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_ValueSetMatchDecider(@_);
    bless $self, $pkg if defined($self);
}

*add_value = *Search::Xapianc::ValueSetMatchDecider_add_value;
*remove_value = *Search::Xapianc::ValueSetMatchDecider_remove_value;
*__call__ = *Search::Xapianc::ValueSetMatchDecider___call__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_ValueSetMatchDecider($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Search::Xapian::Compactor ##############

package Search::Xapian::Compactor;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Search::Xapian );
%OWNER = ();
%ITERATORS = ();
*STANDARD = *Search::Xapianc::Compactor_STANDARD;
*FULL = *Search::Xapianc::Compactor_FULL;
*FULLER = *Search::Xapianc::Compactor_FULLER;
sub new {
    my $pkg = shift;
    my $self = Search::Xapianc::new_Compactor(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Search::Xapianc::delete_Compactor($self);
        delete $OWNER{$self};
    }
}

*set_block_size = *Search::Xapianc::Compactor_set_block_size;
*set_renumber = *Search::Xapianc::Compactor_set_renumber;
*set_multipass = *Search::Xapianc::Compactor_set_multipass;
*set_compaction_level = *Search::Xapianc::Compactor_set_compaction_level;
*set_destdir = *Search::Xapianc::Compactor_set_destdir;
*add_source = *Search::Xapianc::Compactor_add_source;
*compact = *Search::Xapianc::Compactor_compact;
*set_status = *Search::Xapianc::Compactor_set_status;
*resolve_duplicate_metadata = *Search::Xapianc::Compactor_resolve_duplicate_metadata;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- CONSTANT STUBS -------

package Search::Xapian;

sub OP_AND () { $Search::Xapianc::OP_AND }
sub OP_OR () { $Search::Xapianc::OP_OR }
sub OP_AND_NOT () { $Search::Xapianc::OP_AND_NOT }
sub OP_XOR () { $Search::Xapianc::OP_XOR }
sub OP_AND_MAYBE () { $Search::Xapianc::OP_AND_MAYBE }
sub OP_FILTER () { $Search::Xapianc::OP_FILTER }
sub OP_NEAR () { $Search::Xapianc::OP_NEAR }
sub OP_PHRASE () { $Search::Xapianc::OP_PHRASE }
sub OP_VALUE_RANGE () { $Search::Xapianc::OP_VALUE_RANGE }
sub OP_SCALE_WEIGHT () { $Search::Xapianc::OP_SCALE_WEIGHT }
sub OP_ELITE_SET () { $Search::Xapianc::OP_ELITE_SET }
sub OP_VALUE_GE () { $Search::Xapianc::OP_VALUE_GE }
sub OP_VALUE_LE () { $Search::Xapianc::OP_VALUE_LE }
sub FLAG_BOOLEAN () { $Search::Xapianc::FLAG_BOOLEAN }
sub FLAG_PHRASE () { $Search::Xapianc::FLAG_PHRASE }
sub FLAG_LOVEHATE () { $Search::Xapianc::FLAG_LOVEHATE }
sub FLAG_BOOLEAN_ANY_CASE () { $Search::Xapianc::FLAG_BOOLEAN_ANY_CASE }
sub FLAG_WILDCARD () { $Search::Xapianc::FLAG_WILDCARD }
sub FLAG_PURE_NOT () { $Search::Xapianc::FLAG_PURE_NOT }
sub FLAG_PARTIAL () { $Search::Xapianc::FLAG_PARTIAL }
sub FLAG_SPELLING_CORRECTION () { $Search::Xapianc::FLAG_SPELLING_CORRECTION }
sub FLAG_SYNONYM () { $Search::Xapianc::FLAG_SYNONYM }
sub FLAG_AUTO_SYNONYMS () { $Search::Xapianc::FLAG_AUTO_SYNONYMS }
sub FLAG_AUTO_MULTIWORD_SYNONYMS () { $Search::Xapianc::FLAG_AUTO_MULTIWORD_SYNONYMS }
sub FLAG_DEFAULT () { $Search::Xapianc::FLAG_DEFAULT }
sub STEM_NONE () { $Search::Xapianc::STEM_NONE }
sub STEM_SOME () { $Search::Xapianc::STEM_SOME }
sub STEM_ALL () { $Search::Xapianc::STEM_ALL }
sub FLAG_SPELLING () { $Search::Xapianc::FLAG_SPELLING }
sub DB_CREATE_OR_OPEN () { $Search::Xapianc::DB_CREATE_OR_OPEN }
sub DB_CREATE () { $Search::Xapianc::DB_CREATE }
sub DB_CREATE_OR_OVERWRITE () { $Search::Xapianc::DB_CREATE_OR_OVERWRITE }
sub DB_OPEN () { $Search::Xapianc::DB_OPEN }

# ------- VARIABLE STUBS --------

package Search::Xapian;

*BAD_VALUENO = *Search::Xapianc::BAD_VALUENO;

package Search::Xapian;

our $VERSION = "1.2.6.0";

# We need to use the RTLD_GLOBAL flag to dlopen() so that other C++
# modules that link against libxapian.so get the *same* value for all the
# weak symbols (eg, the exception classes)
sub dl_load_flags { 0x01 }

# Items to export into caller's namespace by default. Note: do not export
# names by default without a very good reason. Use EXPORT_OK instead.
# Do not simply export all your public functions/methods/constants.

# This allows declaration use Search::Xapian ':all';
# If you do not need this, moving things directly into @EXPORT or @EXPORT_OK
# will save memory.
our %EXPORT_TAGS = (
                    'ops' => [ qw(
                                  OP_AND
                                  OP_OR
                                  OP_AND_NOT
                                  OP_XOR
                                  OP_AND_MAYBE
                                  OP_FILTER
                                  OP_NEAR
                                  OP_PHRASE
				  OP_VALUE_RANGE
				  OP_SCALE_WEIGHT
                                  OP_ELITE_SET
				  OP_VALUE_GE
				  OP_VALUE_LE
                                 ) ],
                    'db' => [ qw(
                                 DB_OPEN
                                 DB_CREATE
                                 DB_CREATE_OR_OPEN
                                 DB_CREATE_OR_OVERWRITE
                                 ) ],
                    'enq_order' => [ qw(
				 ENQ_DESCENDING
				 ENQ_ASCENDING
				 ENQ_DONT_CARE
				   ) ],
                    'qpflags' => [ qw(
				 FLAG_BOOLEAN
				 FLAG_PHRASE
				 FLAG_LOVEHATE
				 FLAG_BOOLEAN_ANY_CASE
				 FLAG_WILDCARD
				 FLAG_PURE_NOT
				 FLAG_PARTIAL
				 FLAG_SPELLING_CORRECTION
				 FLAG_SYNONYM
				 FLAG_AUTO_SYNONYMS
				 FLAG_AUTO_MULTIWORD_SYNONYMS
				 FLAG_DEFAULT
                                 ) ],
                    'qpstem' => [ qw(
				 STEM_NONE
				 STEM_SOME
				 STEM_ALL
                                 ) ]
                   );
$EXPORT_TAGS{standard} = [ @{ $EXPORT_TAGS{'ops'} },
			   @{ $EXPORT_TAGS{'db'} },
			   @{ $EXPORT_TAGS{'qpflags'} },
			   @{ $EXPORT_TAGS{'qpstem'} } ];
$EXPORT_TAGS{all} = [ @{ $EXPORT_TAGS{'standard'} }, @{ $EXPORT_TAGS{'enq_order'} } ];

our @EXPORT_OK = ( @{ $EXPORT_TAGS{'all'} } );

# Preloaded methods go here.

our @OP_NAMES;
foreach (@{ $EXPORT_TAGS{'ops'} }) {
  $OP_NAMES[eval $_] = $_;
}

our @DB_NAMES;
foreach (@{ $EXPORT_TAGS{'db'} }) {
  $DB_NAMES[eval $_] = $_;
}

our @FLAG_NAMES;
foreach (@{ $EXPORT_TAGS{'qpflags'} }) {
  $FLAG_NAMES[eval $_] = $_;
}

our @STEM_NAMES;
foreach (@{ $EXPORT_TAGS{'qpstem'} }) {
  $STEM_NAMES[eval $_] = $_;
}

package Search::Xapian::Database;
sub enquire {
  my $self = shift;
  my $enquire = Search::Xapian::Enquire->new( $self );
  if( @_ ) {
    $enquire->set_query( @_ );
  }
  return $enquire;
}

package Search::Xapian::Enquire;
sub matches {
  my $self = shift;
  return $self->get_mset(@_)->items();
}

package Search::Xapian::ESet;
sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Search::Xapian::ESet', $self );
  return @array;
}

use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub TIEARRAY {
  my $class = shift;
  my $eset = shift;
  return bless $eset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

package Search::Xapian::ESetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Search::Xapian::MSet;
sub items {
  my $self = shift;
  my @array;
  tie( @array, 'Search::Xapian::MSet::Tied', $self );
  return @array;
}

sub TIEARRAY {
  my $class = shift;
  my $mset = shift;
  return bless $mset, $class;
}

sub FETCHSIZE {
    my $self = shift;
    return $self->size();
}

package Search::Xapian::MSetIterator;
use overload '++' => sub { $_[0]->increment() },
	     '--' => sub { $_[0]->prev() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  bless $self, $class;
  return $self;
}

package Search::Xapian::MSet::Tied;
our @ISA = qw(Search::Xapian::MSet);

package Search::Xapian::PositionIterator;
use UNIVERSAL qw( isa );
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             '""' => sub { $_[0]->get_description() },
             '0+' => sub { $_[0]->get_termpos() },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

sub equal() {
  my ($self, $other) = @_;
  if( isa($other, 'Search::Xapian::PositionIterator') ) {
    Search::Xapianc::PositionIterator_equal1($self, $other);
  } else {
    ($self+0) == ($other+0);
  }
}

sub nequal() {
  my ($self, $other) = @_;
  if( isa($other, 'Search::Xapian::PositionIterator') ) {
    Search::Xapianc::PositionIterator_nequal1($self, $other);
  } else {
    ($self+0) != ($other+0);
  }
}

package Search::Xapian::TermGenerator;
sub set_stopper {
    my ($self, $stopper) = @_;
    $self{_stopper} = $stopper;
    set_stopper1( @_ );
}

package Search::Xapian::TermIterator;
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

package Search::Xapian::ValueIterator;
use overload '++' => sub { $_[0]->increment() },
             '='  => sub { $_[0]->clone() },
	     'eq' => sub { $_[0]->equal($_[1]) },
	     'ne' => sub { $_[0]->nequal($_[1]) },
	     '==' => sub { $_[0]->equal($_[1]) },
	     '!=' => sub { $_[0]->nequal($_[1]) },
             'fallback' => 1;

sub clone() {
  my $self = shift;
  my $class = ref( $self );
  my $copy = new( $self );
  bless $copy, $class;
  return $copy;
}

# Adding CLONE_SKIP functions
package Search::Xapian::LogicError;
sub CLONE_SKIP { 1 }
package Search::Xapian::PositionIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::PostingIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::TermIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::Document;
sub CLONE_SKIP { 1 }
package Search::Xapian::PostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValuePostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueWeightPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueMapPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::FixedWeightPostingSource;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSet;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSetIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::ESet;
sub CLONE_SKIP { 1 }
package Search::Xapian::ESetIterator;
sub CLONE_SKIP { 1 }
package Search::Xapian::RSet;
sub CLONE_SKIP { 1 }
package Search::Xapian::MatchDecider;
sub CLONE_SKIP { 1 }
package Search::Xapian::Enquire;
sub CLONE_SKIP { 1 }
package Search::Xapian::Weight;
sub CLONE_SKIP { 1 }
package Search::Xapian::BoolWeight;
sub CLONE_SKIP { 1 }
package Search::Xapian::BM25Weight;
sub CLONE_SKIP { 1 }
package Search::Xapian::TradWeight;
sub CLONE_SKIP { 1 }
package Search::Xapian::Database;
sub CLONE_SKIP { 1 }
package Search::Xapian::WritableDatabase;
sub CLONE_SKIP { 1 }
package Search::Xapian::Query;
sub CLONE_SKIP { 1 }
package Search::Xapian::Stopper;
sub CLONE_SKIP { 1 }
package Search::Xapian::SimpleStopper;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::StringValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::DateValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::NumberValueRangeProcessor;
sub CLONE_SKIP { 1 }
package Search::Xapian::QueryParser;
sub CLONE_SKIP { 1 }
package Search::Xapian::Stem;
sub CLONE_SKIP { 1 }
package Search::Xapian::TermGenerator;
sub CLONE_SKIP { 1 }
package Search::Xapian::Sorter;
sub CLONE_SKIP { 1 }
package Search::Xapian::MultiValueSorter;
sub CLONE_SKIP { 1 }
package Search::Xapian::ReplicationInfo;
sub CLONE_SKIP { 1 }
package Search::Xapian::DatabaseMaster;
sub CLONE_SKIP { 1 }
package Search::Xapian::DatabaseReplica;
sub CLONE_SKIP { 1 }
package Search::Xapian::ValueSetMatchDecider;
sub CLONE_SKIP { 1 }
package Search::Xapian::SerialisationContext;
sub CLONE_SKIP { 1 }
package Search::Xapian::MSet::Tied;
sub CLONE_SKIP { 1 }

# Pod document of Search::Xapian
=head1 NAME

Search::Xapian - Perl frontend to the Xapian C++ search library.

=head1 SYNOPSIS

  use Search::Xapian;

  my $db = Search::Xapian::Database->new( '[DATABASE DIR]' );
  my $enq = $db->enquire( '[QUERY TERM]' );

  printf "Running query '%s'\n", $enq->get_query()->get_description();

  my @matches = $enq->matches(0, 10);

  print scalar(@matches) . " results found\n";

  foreach my $match ( @matches ) {
    my $doc = $match->get_document();
    printf "ID %d %d%% [ %s ]\n", $match->get_docid(), $match->get_percent(), $doc->get_data();
  }

=head1 DESCRIPTION

This module wraps most methods of most Xapian classes. The missing classes
and methods should be added in the future. It also provides a simplified,
more 'perlish' interface to some common operations, as demonstrated above.

There are some gaps in the POD documentation for wrapped classes, but you
can read the Xapian C++ API documentation at
L<http://xapian.org/docs/apidoc/html/annotated.html> for details of
these.  Alternatively, take a look at the code in the examples and tests.

If you want to use Search::Xapian and the threads module together, make
sure you're using Search::Xapian >= 1.0.4.0 and Perl >= 5.8.7.  As of 1.0.4.0,
Search::Xapian uses CLONE_SKIP to make sure that the perl wrapper objects
aren't copied to new threads - without this the underlying C++ objects can get
destroyed more than once.

If you encounter problems, or have any comments, suggestions, patches, etc
please email the Xapian-discuss mailing list (details of which can be found at
L<http://xapian.org/lists>).

=head2 EXPORT

None by default.

=head1 :db

=over 4

=item DB_OPEN

Open a database, fail if database doesn't exist.

=item DB_CREATE

Create a new database, fail if database exists.

=item DB_CREATE_OR_OPEN

Open an existing database, without destroying data, or create a new
database if one doesn't already exist.

=item DB_CREATE_OR_OVERWRITE

Overwrite database if it exists.

=back

=head1 :ops

=over 4

=item OP_AND

Match if both subqueries are satisfied.

=item OP_OR

Match if either subquery is satisfied.

=item OP_AND_NOT

Match if left but not right subquery is satisfied.

=item OP_XOR

Match if left or right, but not both queries are satisfied.

=item OP_AND_MAYBE

Match if left is satisfied, but use weights from both.

=item OP_FILTER

Like OP_AND, but only weight using the left query.

=item OP_NEAR

Match if the words are near each other. The window should be specified, as
a parameter to C<Search::Xapian::Query::Query>, but it defaults to the
number of terms in the list.

=item OP_PHRASE

Match as a phrase (All words in order).

=item OP_ELITE_SET

Select an elite set from the subqueries, and perform a query with these combined as an OR query.

=item OP_VALUE_RANGE

Filter by a range test on a document value.

=back

=head1 :qpflags

=over 4

=item FLAG_DEFAULT

This gives the QueryParser default flag settings, allowing you to easily add
flags to the default ones.

=item FLAG_BOOLEAN

Support AND, OR, etc and bracketted subexpressions.

=item FLAG_LOVEHATE

Support + and -.

=item FLAG_PHRASE

Support quoted phrases.

=item FLAG_BOOLEAN_ANY_CASE

Support AND, OR, etc even if they aren't in ALLCAPS.

=item FLAG_WILDCARD

Support right truncation (e.g. Xap*).

=item FLAG_PURE_NOT

Allow queries such as 'NOT apples'.

These require the use of a list of all documents in the database
which is potentially expensive, so this feature isn't enabled by
default.

=item FLAG_PARTIAL

Enable partial matching.

Partial matching causes the parser to treat the query as a
"partially entered" search.  This will automatically treat the
final word as a wildcarded match, unless it is followed by
whitespace, to produce more stable results from interactive
searches.

=item FLAG_SPELLING_CORRECTION

=item FLAG_SYNONYM

=item FLAG_AUTO_SYNONYMS

=item FLAG_AUTO_MULTIWORD_SYNONYMS

=back

=head1 :qpstem

=over 4

=item STEM_ALL

Stem all terms.

=item STEM_NONE

Don't stem any terms.

=item STEM_SOME

Stem some terms, in a manner compatible with Omega (capitalised words and those
in phrases aren't stemmed).

=back

=head1 :enq_order

=over 4

=item ENQ_ASCENDING

docids sort in ascending order (default)

=item ENQ_DESCENDING

docids sort in descending order

=item ENQ_DONT_CARE

docids sort in whatever order is most efficient for the backend

=back

=head1 :standard

Standard is db + ops + qpflags + qpstem

=head1 Version functions

=over 4

=item major_version

Returns the major version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 1.

=item minor_version

Returns the minor version of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 0.

=item revision

Returns the revision of the Xapian C++ library being used.  E.g. for
Xapian 1.0.9 this would return 9.  In a stable release series, Xapian libraries
with the same minor and major versions are usually ABI compatible, so this
often won't match the third component of $Search::Xapian::VERSION (which is the
version of the Search::Xapian wrappers).

=back

=head1 Numeric encoding functions

=over 4

=item sortable_serialise NUMBER

Convert a floating point number to a string, preserving sort order.

This method converts a floating point number to a string, suitable for
using as a value for numeric range restriction, or for use as a sort
key.

The conversion is platform independent.

The conversion attempts to ensure that, for any pair of values supplied
to the conversion algorithm, the result of comparing the original
values (with a numeric comparison operator) will be the same as the
result of comparing the resulting values (with a string comparison
operator).  On platforms which represent doubles with the precisions
specified by IEEE_754, this will be the case: if the representation of
doubles is more precise, it is possible that two very close doubles
will be mapped to the same string, so will compare equal.

Note also that both zero and -zero will be converted to the same
representation: since these compare equal, this satisfies the
comparison constraint, but it's worth knowing this if you wish to use
the encoding in some situation where this distinction matters.

Handling of NaN isn't (currently) guaranteed to be sensible.

=item sortable_unserialise SERIALISED_NUMBER

Convert a string encoded using sortable_serialise back to a floating
point number.

This expects the input to be a string produced by sortable_serialise().
If the input is not such a string, the value returned is undefined (but
no error will be thrown).

The result of the conversion will be exactly the value which was
supplied to sortable_serialise() when making the string on platforms
which represent doubles with the precisions specified by IEEE_754, but
may be a different (nearby) value on other platforms.

=back

=head1 TODO

=over 4

=item Error Handling

Error handling for all methods liable to generate them.

=item Documentation

Add POD documentation for all classes, where possible just adapted from Xapian
docs.

=item Unwrapped classes

The following Xapian classes are not yet wrapped:
Error (and subclasses), ErrorHandler, ExpandDecider (and subclasses),
user-defined weight classes.

We don't yet wrap Xapian::Query::MatchAll, Xapian::Query::MatchNothing,
or Xapian::BAD_VALUENO.

=item Unwrapped methods

The following methods are not yet wrapped:
Enquire::get_eset(...) with more than two arguments,
Query ctor optional "parameter" parameter,
Remote::open(...),
static Stem::get_available_languages().

We wrap MSet::swap() and MSet::operator[](), but not ESet::swap(),
ESet::operator[]().  Is swap actually useful?  Should we instead tie MSet
and ESet to allow them to just be used as lists?

=back

=head1 CREDITS

Thanks to Tye McQueen E<lt>tye@metronet.comE<gt> for explaining the
finer points of how best to write XS frontends to C++ libraries, James
Aylett E<lt>james@tartarus.orgE<gt> for clarifying the less obvious
aspects of the Xapian API, Tim Brody for patches wrapping ::QueryParser and
::Stopper and especially Olly Betts E<lt>olly@survex.comE<gt> for contributing
advice, bugfixes, and wrapper code for the more obscure classes.

=head1 AUTHOR

Alex Bowley E<lt>kilinrax@cpan.orgE<gt>

Please report any bugs/suggestions to E<lt>xapian-discuss@lists.xapian.orgE<gt>
or use the Xapian bug tracker L<http://xapian.org/bugs>.  Please do
NOT use the CPAN bug tracker or mail any of the authors individually.

=head1 SEE ALSO

L<Search::Xapian::BM25Weight>,
L<Search::Xapian::BoolWeight>,
L<Search::Xapian::Database>,
L<Search::Xapian::Document>,
L<Search::Xapian::Enquire>,
L<Search::Xapian::MultiValueSorter>,
L<Search::Xapian::PositionIterator>,
L<Search::Xapian::PostingIterator>,
L<Search::Xapian::QueryParser>,
L<Search::Xapian::Stem>,
L<Search::Xapian::TermGenerator>,
L<Search::Xapian::TermIterator>,
L<Search::Xapian::TradWeight>,
L<Search::Xapian::ValueIterator>,
L<Search::Xapian::Weight>,
L<Search::Xapian::WritableDatabase>,
and
L<http://xapian.org/>.

=cut
1;
