<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Sorting of Search Results</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 5196 2007-06-03 20:25:28Z wiemann $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="sorting-of-search-results">
<h1 class="title">Sorting of Search Results</h1>

<!-- Copyright (C) 2007,2009 Olly Betts -->
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id1">Introduction</a></li>
<li><a class="reference internal" href="#sorting-by-relevance" id="id2">Sorting by Relevance</a></li>
<li><a class="reference internal" href="#sorting-by-other-properties" id="id3">Sorting by Other Properties</a><ul>
<li><a class="reference internal" href="#sorting-by-value" id="id4">Sorting by Value</a></li>
<li><a class="reference internal" href="#sorting-by-generated-key" id="id5">Sorting by Generated Key</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id1">Introduction</a></h1>
<p>By default, Xapian orders search results by decreasing relevance score.
However, it also allows results to be ordered by other criteria, or
a mixture of other criteria and relevance score.</p>
<p>If two or more results compare equal by the sorting criteria, then their order
is decided by their document ids.  By default, the document ids sort in
ascending order (so a lower document id is &quot;better&quot;), but this can be set
to descending using <tt class="docutils literal"><span class="pre">enquire.set_docid_order(enquire.DESCENDING);</span></tt>.  If you
have no preference, you can tell Xapian to use whatever order is most efficient
using <tt class="docutils literal"><span class="pre">enquire.set_docid_order(enquire.DONT_CARE);</span></tt>.</p>
</div>
<div class="section" id="sorting-by-relevance">
<h1><a class="toc-backref" href="#id2">Sorting by Relevance</a></h1>
<p>The BM25 weighting formula which Xapian uses by default has a number of
parameters.  We have picked some default parameter values which do a good job
in general.  The optimal values of these parameters depend on the data being
indexed and the type of queries being run, so you may be able to improve the
effectiveness of your search system by adjusting these values, but it's a
fiddly process to tune them so people tend not to bother.</p>
<p>See the <a class="reference external" href="bm25.html">BM25 documentation</a> for more details of BM25.</p>
<p>The other included weighting schemes are <tt class="docutils literal"><span class="pre">TradWeight</span></tt> and <tt class="docutils literal"><span class="pre">BoolWeight</span></tt>.</p>
<p>TradWeight implements the original probabilistic weighting formula, which is
essentially a special case of BM25 (it's BM25 with k2 = 0, k3 = 0, b = 1, and
min_normlen = 0, except that the weights are scaled by a constant factor).</p>
<p>BoolWeight assigns a weight of 0 to all documents, so the ordering is
determined solely by other factors.</p>
<p>You can also implement your own weighting scheme, provided it can be expressed
in the form of a sum over the matching terms, plus an extra term which depends
on term-independent statistics (such as the normalised document length).</p>
<p>For example, here's an implementation of &quot;coordinate matching&quot; - each matching
term scores one point:</p>
<pre class="literal-block">
class CoordinateWeight : public Xapian::Weight {
  public:
    CoordinateWeight * clone() const { return new CoordinateWeight; }
    CoordinateWeight() { }
    ~CoordinateWeight() { }

    std::string name() const { return &quot;Coord&quot;; }
    std::string serialise() const { return &quot;&quot;; }
    CoordinateWeight * unserialise(const std::string &amp;) const {
        return new CoordinateWeight;
    }

    Xapian::weight get_sumpart(Xapian::termcount, Xapian::doclength) const {
        return 1;
    }
    Xapian::weight get_maxpart() const { return 1; }

    Xapian::weight get_sumextra(Xapian::doclength) const { return 0; }
    Xapian::weight get_maxextra() const { return 0; }

    bool get_sumpart_needs_doclength() const { return false; }
};
</pre>
<!-- FIXME: add a more complex example once user-defined weight classes can
see the statistics. -->
</div>
<div class="section" id="sorting-by-other-properties">
<h1><a class="toc-backref" href="#id3">Sorting by Other Properties</a></h1>
<p>If you want to offer a &quot;sort by date&quot; feature, and can arrange for documents to
be indexed in date order (or a close-enough approximation), then you can
implement a very efficient &quot;sort by date&quot; feature by using a boolean search
(i.e. call <tt class="docutils literal"><span class="pre">enquire.set_weighting_scheme(Xapian::BoolWeight());</span></tt>) with
<tt class="docutils literal"><span class="pre">enquire.set_docid_order(Xapian::Enquire::DESCENDING);</span></tt> (for newest first) or
<tt class="docutils literal"><span class="pre">enquire.set_docid_order(Xapian::Enquire::ASCENDING);</span></tt> (for oldest first).
There's no inherent reason why this technique can't be used for sorting by
something other than date, but it's usually much easier to arrange for new
documents to arrive in date order than in other orders.</p>
<div class="section" id="sorting-by-value">
<h2><a class="toc-backref" href="#id4">Sorting by Value</a></h2>
<p>You can order documents by comparing a specified document value.  Note that the
comparison used compares the byte values in the value (i.e. it's a string sort
ignoring locale), so <tt class="docutils literal"><span class="pre">1</span></tt> &lt; <tt class="docutils literal"><span class="pre">10</span></tt> &lt; <tt class="docutils literal"><span class="pre">2</span></tt>.  If you want to encode the value
such that it sorts numerically, use <tt class="docutils literal"><span class="pre">Xapian::sortable_serialise()</span></tt> to encode
values at index time - this works equally will on integers and floating point
values:</p>
<pre class="literal-block">
Xapian::Document doc;
doc.add_value(0, Xapian::sortable_serialise(price));
</pre>
<p>There are three methods which are used to specify how the value is used to
sort, depending if/how you want relevance used in the ordering:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Enquire::set_sort_by_value()</span></tt> specifies the relevance doesn't affect the
ordering at all.</li>
<li><tt class="docutils literal"><span class="pre">Enquire::set_sort_by_value_then_relevance()</span></tt> specifies that relevance is
used for ordering any groups of documents for which the value is the same.</li>
<li><tt class="docutils literal"><span class="pre">Enquire::set_sort_by_relevance_then_value()</span></tt> specifies that documents are
ordered by relevance, and the value is only used to order groups of documents
with identical relevance values (note: the weight has to be the same, not
just the rounded percentage score).  This method isn't very useful with the
default BM25 weighting, which rarely assigns identical scores to
different documents.</li>
</ul>
</blockquote>
</div>
<div class="section" id="sorting-by-generated-key">
<h2><a class="toc-backref" href="#id5">Sorting by Generated Key</a></h2>
<p>To allow more elaborate sorting schemes, Xapian allows you to provide a functor
object subclassed from <tt class="docutils literal"><span class="pre">Xapian::KeyMaker</span></tt> which generates a sort key for each
matching document which is under consideration.  This is called at most once
for each document, and then the generated sort keys are ordered by comparing
byte values (i.e. with a string sort ignoring locale).</p>
<p>There's a standard subclass <tt class="docutils literal"><span class="pre">Xapian::MultiValueKeyMaker</span></tt> which allows sorting
on more than one document value (so the first document value specified
determines the order except among groups which have the same value, when
the second document value specified is used, and so on).</p>
<p><tt class="docutils literal"><span class="pre">Xapian::KeyMaker</span></tt> can also be subclassed to offer features such as &quot;sort by
geographical distance&quot;.  A subclass could take a coordinate pair - e.g.
(latitude, longitude) - for the user's location and sort results using
coordinates stored in a document value so that the nearest results ranked
highest.</p>
</div>
</div>
</div>
</body>
</html>
